---
title: '【论文阅读笔记】Mobility-Aware Dynamic Taxi Ridesharing'
date: 2021-10-28
permalink: /posts/2021/10/mtshare/
tags:
  - mobility pattern
  - route planning
  - taxi ridesharing
---

[原文链接](https://liuzhidan.github.io/pdf/2020-ICDE-mTShare.pdf)
# Background
如今，拼车已成为一种流行的出行方式。滴滴等大型网约车公司已经开始大规模开放这种乘车方式，而之前因网约车的崛起而备受冲击的出租车行业也开始寻求向互联网方面转型。本文探究的就是针对出租车的一种拼车方式。
需要注意的是，此处的“拼车”并非指几个人提前商量好，由一人下单，多人同时乘车。也和私家车拼车那种专门用于应对日常上下班通勤的方式不同。以上两种拼车，所有乘客的出发地、目的地信息都能提前预知。而本文研究的出租车拼车，是指当车上已有一名乘客时，司机选择在半路接上一位新乘客，类似“顺风车”的概念，乘客之间相互并不认识，只是他们的行程比较类似。（第一次阅读的时候，ridesharing的概念困扰了我很久）

# Related Work
T-Share: a large-scale dynamic taxi ridesharing service 
TASeT: improving the efficiency of electric taxis with transfer-allowed rideshare
QAshare: towards efficient QoS-aware dispatching approach for urban taxisharing 
A user-oriented taxi ridesharing system with large-scale urban GPS sensor data
以上为该领域的一些相关研究。这些研究存在种种局限：
（1）一个最普遍的问题是：这些研究都针对网约车行业的拼车，也就是只针对线上的需求。而出租车与网约车最大的区别就是，有许多乘客选择在路边拦车，也就是存在大量线下的需求。根据嘀嗒出行发布的《全国一线城市出租车行业服务水平研究报告》显示，还有将近一半的乘客会选择扬招的方式乘车，而相关研究都没有考虑这一方面。
![image](https://github.com/user-attachments/assets/f54ef7fc-4f71-48c0-97ab-7f5a6cf5eb41)
（2）部分研究工作仅利用乘客的目的地信息进行后续的分析。由于位置信息太简单，导致后续为乘客匹配的出租车并非最佳结果。
（3）直接为乘客匹配一辆空车，无法体现拼车的特征。
![image](https://github.com/user-attachments/assets/f1cb9c5d-82cc-4103-b8fc-7f4342926d39)
我们用一张图来说明一下相关工作的局限性。有乘客在线上提交了订单r1，其目的地为D1。根据相关工作的做法，以r1位置为圆心，不断扩大范围去搜索出租车。当范围扩大到虚线位置，会将t1和t2设为候选车辆。之后再根据一系列计算，也许会将t1匹配给r1。然而通过我们观察可以发现：
（1）t3显然是比t1更好的选择。因为t3的行驶方向与r1的目的地方向相近，且不需要过多的绕行。
（2）t2显然与r1不匹配。因为t2的行驶方向与r1的目的地方向相反。然而在范围搜索时，t2竟被选为候选车辆，这无疑增加了后续的计算成本。
（3）我们完全可以通过路径规划，让t2能服务r2订单。而相关工作中没有考虑线下需求。

# Problem Definition
基于以上问题，我们提出了一种新的构想：MTR（Mobility-aware Taxi Ridesharing problem）问题。我们希望：
（1）将线上需求和线下需求都考虑在内。
（2）实现服务订单数量最大化和车辆绕行开销最小化。
（3）满足车辆容量限制，且能在乘客要求的时间内到达目的地。
我们需要克服的主要困难为：
（1）如何高效地匹配出租车（响应速度快、匹配结果优）
（2）如何为司机智能规划路线
（3）如何对难以预知的线下需求做出合理预测。

# System Design
![image](https://github.com/user-attachments/assets/f563c3e2-8953-48d0-aab0-6011bb6dc085)
为了解决MTR问题，我们对此提出了mT-Share的系统架构。
该系统的输入数据包括：实时的订单信息和出租车当前状态信息、历史的出租车数据和道路图。后续通过两个模块：出租车/订单索引、乘客/出租车匹配，来最终实现为乘客匹配最佳车辆。下面我们着重探究两个模块的实现原理。

# Taxi/Request Indexing
该模块是通过地图划分、移动聚类和出租车索引这三个小部分来实现的。目的是基于地理位置信息和行程方向来对乘客需求和出租车进行索引和追踪。
（1）地图划分：其目的是将一个大的城市道路图划分为多个分区，每个分区内的点具有某种相似的特征。我们首先基于地理位置信息，利用K-means算法将所有点划分为k个簇，之后计算每个点的转移概率向量。以图为例，根据历史数据我们算出乘客从点i出发前往a、b、c三个簇的概率分别为0.2、0.3和0.5，则点i的转移概率向量Bi就为0.2、0.3、0.5。之后我们再次利用K-means算法，基于上一步求得的概率，将所有顶点划分为kt个簇。之后重复这三个步骤，直到步骤一的结果不变为止。
![image](https://github.com/user-attachments/assets/f5cb54b1-26ae-4922-ba2d-9eb6e074d679)
通过这一步，我们最终得到的各个分区中的节点既满足地理位置上的相近，又拥有相似的转移模式。下图是对成都市道路网划分的结果（K-means中k值设为20）。
![image](https://github.com/user-attachments/assets/29fd217f-7af0-4a9e-866d-1dbe7c1ccef5)
（2）移动聚类：我们为乘客需求和出租车创建移动向量
![image](https://github.com/user-attachments/assets/96571840-cd00-4da4-915e-50dc8dc8d517)
向量包含出发地和目的地的经纬度信息，其中出租车的出发地为车辆的当前位置，目的地信息是根据车上所有乘客的信息计算的平均值。之后我们根据地图划分中获得的簇，为每个簇计算它们的通用移动向量（general mobility vector），也就是对所有点计算平均值的结果。之后，如果有乘客提交了新的需求，我们会将其和簇的通用移动向量进行比较，若二者夹角的cos值满足条件：
![image](https://github.com/user-attachments/assets/1ae1db26-03ca-4f44-95f6-47416fb979e1)
则将该需求添加到该簇中，即该需求与簇中原有需求的移动方向相似，反之该需求将自己形成一个新簇。每当有订单完成或新订单加入时，我们就会对簇的向量信息进行更新。
（3）出租车索引：根据前两个模块的结果，我们将建立两种索引方式。在基于地图划分的索引中，我们将寻找正处在该分区内的或在限定时间内可到达该分区的出租车，并建立表格存储出租车信息。在基于移动聚类的索引中，我们将寻找车上正带有乘客且行驶方向相近的出租车，同样用一个表存储起来。以上就是出租车/订单索引模块的内容。

# Passenger-Taxi Matching
该模块主要包括候选出租车搜索和车辆安排两个部分。目的是基于上一模块的结果，为乘客匹配最合适的出租车。
（1）候选出租车搜索。我们将设置一个搜索范围γ。不同于其他研究中γ是从小到大变化的，我们将γ设为一个定值，该值为车辆速度和乘客等待时间的乘积。其中车辆速度（typical driving speed）应该是通过社会调查得到的车辆常规行驶速度，乘客等待时间为到达目的地的最晚时间 - 路上花费的时间 - 乘客提交订单时间：
![image](https://github.com/user-attachments/assets/aa7f09c0-c173-468d-9f65-6f64e92d5a78)
之后我们获取与该搜索范围相交的分区的车辆索引表。举个例子，图中红点为刚刚提交需求的乘客的位置，蓝圈为搜索范围，则1、2、7分区就是我们的候选分区。我们将获取这些分区中的出租车索引表。
![image](https://github.com/user-attachments/assets/a8c2468e-eaea-4139-a062-fea9e862f6d8)
下一步，我们再将乘客需求与所有移动簇进行比较，获取方向相近的簇的集合（满足上面cos的那个条件）。
最终，我们的候选出租车集合为上述两步得到的出租车索引表和簇集合的交集：
![image](https://github.com/user-attachments/assets/32a49705-3c09-4798-bd0f-7696ef7de1d4)
这样，选出的候选出租车既满足分区位置接近，也满足行驶方向相似。
（2）出租车安排：这一步主要通过计算加入一个新订单后额外增加的绕行开销，来为乘客匹配最合适的车辆。而在计算出租车的绕行开销之前，我们需要先对出租车进行路线规划。算法1为出租车安排算法，其中通过标识符flag选择不同的路线规划方式。flag的含义在后面内容中会提到。
![image](https://github.com/user-attachments/assets/b31cff4e-a299-4e65-a7ee-8eddbe6a42b3)
首先第一步是分区过滤，这一步的目的是选出候选分区，过滤掉无用分区，为下一步路线规划尽可能减少计算成本。对于两个连续的乘客订单，我们计算车辆途经某分区的行驶方向差异（此处没有弄明白，尤其是图中θ角的含义）和行驶开销。
![image](https://github.com/user-attachments/assets/d7eb79f1-00f2-40f4-928d-459d3766d7dc)
若二者都在可接受范围内，则将该分区加入候选分区。
![image](https://github.com/user-attachments/assets/5022b690-8219-4c21-a781-1e2631f916ba)
下一步进行路线规划，为适应不同的场景我们设计了两种规划方式。当线上需求量巨大，而线下需求不多时，我们选择基础路线规划。这种方式使用迪杰斯特拉算法计算两个连续需求之间的最短距离。而当线上需求不多时，为了尽可能的遇到线下乘客，我们可以选择概率路线规划。这种方式首先计算在某分区中遇到合适乘客的概率，而此概率在之前的地图划分模块中计算过了（转移概率向量），因此可以直接复用。之后，我们将上述概率作为每个分区标志点的权值。通过枚举从出发地分区到目的地分区的所有可能路线，并计算每种路线的总权值。总权值最大的路线即为遇到线下乘客概率最大的分区转移路线（红线）。该路线仅指明了司机要经过哪几个分区。因此在之后，我们对上述路线进行细粒度划分，基于迪杰斯特拉算法找出遇到线下乘客概率最大，且符合车内已有乘客时间限制的路径。该路径即为最终路径（绿线）。
![image](https://github.com/user-attachments/assets/acaf842c-52b9-42d7-a7f7-acf8869a0a41)
这里解释之前算法1中的flag。其含义就是“该出租车当前空间充裕且线上需求量不大”。符合该条件时，司机可以选择概率路线规划，最大可能的遇到线下乘客，反之则选择基础路线规划。至此，mT-Share的系统设计介绍完毕。

# Performance Evaluation
对该系统表现的评估，论文中的图表达的很详细，这里就简单说明一下：
我们拿mT-Share与其他四种同领域的研究做对比：No-Sharing works、T-share、pGreedyDP、mT-Sharepro，其中mT-Sharepro是mT-Share采用概率路线规划的版本。
结果是，mT-Share对服务订单的数量有明显提升；同时，由于引入了对线下乘客的预测，其响应时间和绕行开销有所增加，但都在可接受范围内。

# Conclusion
为了更好的发展出租车拼车市场，我们提出了MTR问题，希望兼顾线上需求与线下需求，实现服务数量最大化和绕行开销最小化，同时满足车辆容量和接送时间的限制。为了实现以上要求，我们设计了mT-Share系统，该系统通过两大模块实现了为乘客匹配最合适的出租车，同时为司机规划最优路线，还能兼顾线下乘客需求。之后我们通过实验，将mT-Share与市面上已有的经典方案进行了比较，结果是我们的mT-Share在服务数量、响应时间和绕行开销方面都表现良好，对服务数量的提升尤为突出。

# 阅读感受
本文其实具体的思想并不复杂，使用的K-means、迪杰斯特拉算法都是很经典的方法。关键在于明白该论文要做一件什么事（ridesharing的概念），以及mT-Share系统的架构。尤其系统架构，包含的模块比较多，每个模块的步骤也比较多。能够理清整个逻辑的话，理解起来应该不是很难。

------
