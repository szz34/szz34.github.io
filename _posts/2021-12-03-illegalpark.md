---
title: '【论文阅读笔记】Detecting Vehicle Illegal Parking Events using Sharing Bikes' Trajectories'
date: 2021-12-03
permalink: /posts/2021/12/illegalpark/
tags:
  - Trajectory Data Mining
  - Urban Planning
  - Urban Computing
---

[原文链接](https://dl.acm.org/doi/10.1145/3219819.3219887)

先看一眼论文的作者，是郑宇博士组的成果，就知道这篇论文的质量肯定差不了了。对urban computing感兴趣的小伙伴可以多关注郑宇博士的一些成果，很厉害。

# Background
看了论文标题就差不多知道这篇论文要做什么，就是基于共享单车的轨迹信息来检测路边的违章停车现象。传统方法一般是靠交警巡逻或者监控摄像头，要么太耗费人力，要么部署费用太高且难以覆盖城市的每个角落，因此作者希望开发一种具有普适性的算法来解决该问题。

# Introduction
作者通过观察发现：停在路边的违章车辆会影响骑行者的轨迹。在没有违章车辆时，骑行者一般会沿着路边正常骑行，而遇到违章车辆时，就会拐一个弯，刻意避开车辆。作者就想到，也许可以通过分析自行车的轨迹来检测违章车辆的存在。

![image](https://github.com/user-attachments/assets/b11ce212-c090-4300-81d1-2cbf070423e7)

刚好摩拜单车的数据为这一构想提供了可能。当时的摩拜（2017-2018）具有两亿的注册用户，每天就可以产生三千万条骑行记录，轨迹基本可以覆盖到大城市（此文以北京为例）的各个角落。

![image](https://github.com/user-attachments/assets/1b694988-0c93-4068-bcef-813fc21a9ee2)

同时数据的质量也比较高，GPS可以做到大约每隔6秒或者6米采集一次定位数据，最终呈现出来的轨迹也比较精细。

![image](https://github.com/user-attachments/assets/e15107be-a162-469b-9169-9321cb1111ad)

然后作者就去做了一些小实验去验证该做法的可行性。作者在路边划出一片区域来模拟违章车辆，并骑上摩拜单车。

![image](https://github.com/user-attachments/assets/77a37af4-48c1-4f6b-99c7-9f346ab03f70)

首先假设车辆不存在，正常骑过去，重复多次，再假设车辆存在，刻意绕开骑行，重复多次。最后提取了单车的轨迹。可以明显看到，当车辆存在时，单车的轨迹要更加曲折，向路边的反方向偏移。这一结论证明我们的想法是可行的。

![image](https://github.com/user-attachments/assets/d63eedb1-6414-4780-98b1-7d997cfaa480)

# Challenges
想要实现对违章车辆的检测，还需要克服几个困难。

首先就是难以避免的手机GPS定位误差问题，有时人为的操作失误也会带来误差，比如忘记关锁还车。

同时由于GPS误差的存在，就必须对单车轨迹做路网匹配（map-matching），这也是基本上有关轨迹问题中都要进行的一步。因为如果直接将GPS点映射到路网上，轨迹可能不会刚好落在道路上，我们需要对其进行一个校正。

![image](https://github.com/user-attachments/assets/baa07462-3cac-45bc-b6dc-cac56fa15a86)

第三个难点就是检测功能的实现，因为市面上不存在有关违章车辆的有标签的数据集供我们进行模型训练，现实的场景也比之前模拟的场景要更复杂。

最后就是要保证检测系统的效率。

# Overview
给定我们共享单车的轨迹数据，由一系列的GPS点组成，每个点包含经纬度信息和时间。道路网数据，包括路段E以及路段之间的交汇点V，其中E包含三个属性，level表示该路段的类型，比如高速公路、慢车道、高架桥等；shape表示由一系列位置点体现的路段的大致形状，dir表示车辆在上面行驶的方向。我们希望通过这些数据去检测路边违章车辆的存在，同时保证准确率和响应时间。

![image](https://github.com/user-attachments/assets/029ed6c4-b03b-495a-a172-bc82f09c6091)

下面是整个系统的架构图，主要包括数据预处理和功能实现两大模块：

![image](https://github.com/user-attachments/assets/128ccb24-1907-4c69-b365-03b6a52671f5)

# TRAJECTORY PRE-PROCESSING
## Trajectory Data Cleaning
首先来看数据预处理模块。该模块的第一个步骤是数据清洗。这一步删除了速度异常和采样率异常的数据，比如有时骑行者忘记关锁然后去乘坐地铁，会导致速度过快，骑行者等红绿灯的情况可能导致速度过慢。而采样率异常一般是由GPS传感器故障引起的。当然在删除数据时，并不是直接删掉整条轨迹，而是去除异常的部分。

![image](https://github.com/user-attachments/assets/afea8127-d1e0-4b63-aa44-96665153c173)

## Trajectory Map-Matching
第二个步骤是路网匹配。作者采用了一种基于互动投票的路网匹配算法，其实也是他们组在之前的一个贡献。感兴趣的小伙伴可以去看原论文（An Interactive-Voting Based Map Matching Algorithm），或者去看软件学报上的《路网匹配算法综述》，这边就先不展开讲了。在路网匹配完成后，每个GPS采样点都会获得三个属性，分别是：与之匹配的路段ID，距该路段的最短距离shift，如果该点位于路段的左侧，其值为正，在右侧则为负。还有该点相对于路段的起点所移动的距离offset，比如对于P2这个点，黄色部分的距离就是它的offset。这些信息在后续的工作中会用到，一定要清楚各自的含义。

![image](https://github.com/user-attachments/assets/96f1b13e-da3a-4adc-830f-8b1a581676a8)

虽然完成了路网匹配，但其中可能存在一些有问题的结果，包括距离和方向的错误。

因此作者又基于几何原理，对结果做了进一步处理。例如，当骑行者驶入一片住宅区，由于地图数据不够完善，没有包含这一片区域的路段信息，路网匹配只能将这段轨迹匹配到一个相对比较近的路段上，然而实际的距离可能非常远。

![image](https://github.com/user-attachments/assets/a4f65f99-8b4e-438b-bc03-a5c06d2d5ae7)

而方向错误一般是由数据集中一些很短的轨迹导致的，路网匹配可能会直接将其匹配到一个比较近的路段，而很显然轨迹的方向和路段的方向是截然不同的。

![image](https://github.com/user-attachments/assets/599f79a3-5b86-4662-baee-9ebf68ce2385)

对于距离错误，如果轨迹的平均shift值大于20m，就将其删掉。对于方向错误，我们将轨迹分成前后两部分，对于每部分计算所有GPS点的一个中心点，如果两个中心点的连线与路段的夹角大于60度，就将其删掉。

![image](https://github.com/user-attachments/assets/58aa0b1e-09a3-4d00-9964-2a08be61eb49)

最后，作者还将逆行的轨迹删掉了，因为逆行单车的轨迹除了受到违章车辆的影响之外，还可能受到其他正常行驶的单车的影响。到此，整个路网匹配过程才算结束。

## Index Construction
数据预处理的最后一步，作者基于路段ID构建索引，之后又基于时间信息构建了二级索引，可以方便我们后续查看某路段在某一时间段的违章停车情况。

# ILLEGAL PARKING DETECTION
## Challenges
下面要做的就是实现我们的检测功能。我们面临这样三个困难：首先，违章停车这一场景在现实中是比较复杂的，可能存在多种情况，因此想要直接去检测违章车辆是比较困难的。既然如此，我们也许可以尝试先为正常的场景，也就是不存在违章车辆的情况进行建模，因为这种场景比较单一，之后再拿数据与正常的情况做比较，如果差异较大就认为有违章车辆的存在。

![image](https://github.com/user-attachments/assets/5fc8bc27-a560-4747-8e8a-b7692ad245d0)

第二个问题是，我们不可以仅靠一条单车轨迹去得出结论，因为随机性较高，可能有人就喜欢在路上拐着弯的骑。所以我们应该尝试通过聚集许多条轨迹，得出综合的结果。

![image](https://github.com/user-attachments/assets/64a9184b-0a6f-4f40-86ec-0f879426c55d)

第三个问题是不同地区的GPS精度可能不同，比如开阔的田野肯定比商业区的定位精度要高。因此我们最好对每条路段单独进行建模。

![image](https://github.com/user-attachments/assets/068252dc-f58e-41e6-8c60-882e6ef433a6)

## Baseline Trajectory Modelling
第一步，我们基于正常情况，也就是没有违章停车的情况建立基准模型。这里提供了两种方案，第一种方案是，作者认为如果路边没有违章车辆，骑行者应该沿着道路的形状骑行，因此直接以道路形状进行建模。第二种方案是，作者认为在深夜违章停车的情况很少，因此他选择时间在晚上11点到早上7点的单车轨迹进行建模。考虑到在深夜骑车的人很少，作者采用了长达六个月的轨迹数据，来尽可能的保证数据量。

## Evaluation Trajectory Feature Extraction
第二步我们对轨迹进行特征提取，我们用到的信息是GPS点的shift值，因为它反映了该点与路边的距离。如果存在一些较大的shift值，就表明可能存在违章车辆。

![image](https://github.com/user-attachments/assets/feece23e-c8eb-4ad9-9a42-dd97c8c18502)

这里也提供了两种方案，第一种是计算每五米内所有GPS点的平均shift值，如图b中的红点。

第二种方案是直接提取该轨迹中shift最大的十个点，如图c。

![image](https://github.com/user-attachments/assets/c7e3cec1-7040-4916-83ed-ea14e397d06f)

## Distribution Test-based Detection
在第三步，我们拿轨迹特征与基准模型的特征做对比，以实现检测的功能。具体做法是通过KS检验。我们将这张shift分布图绘制成累计概率分布图的形式。

![image](https://github.com/user-attachments/assets/7456ad2b-7bc7-40de-a2ae-ff4f62915882)

如果轨迹特征的概率分布与基准模型的概率分布差异较大，则认为有违章停车的情况。评判的标准是，我们将两条分布的最大垂直落差值设为KS检验的统计量Dnm，n和m分别为两条分布所含的点数，之后通过该公式计算KS检验的临界值Dα，其中α为显著性水平。最后将Dnm与Dα做比较，若Dnm小于Dα，说明两条分布比较接近，若此时α等于0.05，我们就可以以95%的概率接受原假设，也就是没有违章车辆。反之就拒绝原假设。

![image](https://github.com/user-attachments/assets/f2cda9c6-fe0b-4a6f-9aab-b32176c309d4)

至此，我们完成了对检测功能的实现。

# Experiments
关于系统如何在Apache Storm中部署的，有兴趣的小伙伴可以再去看看原文，这里就不介绍了。
## Datasets
下面我们通过一些实验来评估我们系统的表现。采用的数据集包括：

（1）来自OpenStreetMap的北京市道路网；

（2）来自摩拜单车的轨迹数据；

（3）作者实地采集的一些真实数据，包括路段ID，采集时间，路段的照片，以及是否存在违章车辆。一共采集了454条道路数据，其中159条存在违章停车。

## Threshold Selection
我们首先做的是，选取最佳的α值。因为在KS检验中，α的值决定了临界值的大小，进一步可能影响模型的准确率，因此我们需要选取最佳的α值。做法也很直接，我们从0到1，每隔0.01取一个α值，枚举所有可能，评价标准是常用的F1值、精确率（precision）和召回率（recall）。最终我们选择0.71作为α的值，因为此时F1值可以取到最大值。

![image](https://github.com/user-attachments/assets/b576ba55-decc-4fc8-9e96-80e728565551)

## Compare with Baselines
第二步，我们对之前提到的不同方案的表现做一个评估，比如在建立基准模型时，有基于道路形状和基于深夜轨迹两种建模方案，也就是这里的naïve和Nt。在特征提取中有基于平均值和最大值两种方案。Nt+Dir就是采用夜晚轨迹，平均值提取的方案，同时还去除了逆行的轨迹。Nt+Dir+T相比于前者，使用了基于最大值的特征提取。我们为这四种方案绘制了各自的ROC曲线，曲线下包含的面积越大，说明模型表现越好。可以看到，第四种方案明显优于其他模型。

![image](https://github.com/user-attachments/assets/681fcb98-75d0-4b29-9a0b-1d8fdb28276c)

## Trajectory Numbers
最后我们分析了轨迹数量对模型表现的影响，也就是至少基于多少条轨迹得到的结果才比较准确。结果发现，轨迹数越多表现越好，但当数量达到30条时，模型就可以达到一个很好的效果。

![image](https://github.com/user-attachments/assets/e5884176-5a6c-4f8a-b03a-f0966b7f4992)

## Response Time
关于系统的响应时间，通过下图可以看到：我们通过适量的增加分布式工作节点的数量来控制系统的执行时间，比如我们想查看过去几个小时内道路的违停情况，执行时间可以控制在100s以内。

![image](https://github.com/user-attachments/assets/336b29a0-dd03-4897-a7e7-377bdf187ed4)

# Conclusion
最后做个总结。作者希望帮助城市管理者解决违章停车问题，传统方法具有诸多不便，因此提出了基于共享单车轨迹的检测方法，整个系统主要包括数据预处理和功能实现两部分。最后通过实验对系统表现做了评估，准确率和响应时间都很可观。同时作者还提到该系统仍有不足之处需要改善，例如骑行者轨迹的变化不一定是由违章车辆引起的，例如当路边存在道路施工时，骑行者的轨迹也会有类似的变化，后续将会研究如何解决。

# One More Thing
我去看了一下该文一作在KDD现场讲解的视频，作者最后对两个问题做了回答，也是困扰我的两个问题。

第一个是，在建立基准模型时，一种方案是使用深夜的轨迹进行建模，这样就有两个问题，第一是深夜骑行者很少，如何保证数据量。这个问题很好解决，尽可能的拉大时间的跨度就可以了，比如说原文是使用了整整六个月的数据。第二个问题是，不能保证在深夜没有违停的情况出现，对于该问题，其实原文中也有提到说这不是文章关注的重点；作者在现场的回答是，通过他的观察，北京深夜基本没有违停车辆（好像是这么说的，英语听得不是很清楚），该回答还是让我对该问题很困惑。

第二个是，文章最后提到要改进的地方，就比如路边施工也会对骑行者的轨迹产生类似影响，作者暂时的想法是：进一步深挖时间信息，比如施工一般会持续几天，而违停一般是几个小时的事，我觉得这是一个可行的方法，但现实情况要复杂的多，可能还有许多其他类似的影响因素，仍需进一步改进。

# 阅读感受
我选择去看这篇论文的原因，首先它的Idea很新奇，能够将共享单车和违章停车联系起来。其次该论文从想法提出，到最后部署应用，整个过程很完整，尤其在数据预处理模块的一些处理方式值得学习。

------
